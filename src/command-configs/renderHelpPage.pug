html
  head
    title Help - Command Bot
    meta(name="color-scheme" content="light dark")
    link(rel="stylesheet" href="https://cdn.jsdelivr.net/npm/minstyle.io@2.0.1/dist/css/minstyle.io.min.css")
    script(type="text/javascript" src="https://cdn.jsdelivr.net/npm/dark-mode-switcher@0.0.1/dist/dark.min.js")

  body
    article.container
      div.ms-hero.mb-lg
        div.ms-hero-body
          h1.ms-hero-title Command Bot - Help Docs
          div.ms-hero-content
            p
              | Based on
              a(href=repoLink) #{repoLink}
            p rev: #{scriptsRevision}
            p running custom commands, like:
              br
              code #{commandStart} command-name -v VAR=value id --argument=1 --argument=2
            p to add new command:
              ul
                li go to
                  a(href=config.pipelineScripts.repository) #{config.pipelineScripts.repository}
                li add new command and open PR
                li read
                  a(href="\#link-new-command") how to test new command before merging
                li merge. Then after merge PR, it accessible without branch override

      div.row
        div.col-3
          div.sticky-nav
            label(for="repos") Select repo:
              select.mt-sm(id="repos")
                option(value="") All Repos
                each repo in repos
                  option(value=repo) #{repo}
            | Commands Navigation:
            each cfg, commandName in commandConfigs
              ul.nav
                li.nav-command
                  a(href="\#link-" + commandName) #{ commandName }
                  if cfg.command.presets
                    ul.nav-preset
                      each preset, presetId in cfg.command.presets
                        li(class="preset-link " + preset.repos.join(' '))
                          a(href="\#link-" + presetId) #{ presetId }
            | Env Variables
            ul
              li
                a(href="\#link-companion") Patch Companion
              li
                a(href="\#link-new-command") How to test new command (test dev branch)
              li
                a(href="\#link-rust") Rust Log, etc

        div.col-8
          each cfg, commandName in commandConfigs
            div.command
              h4(id="link-" + commandName) #{ commandName }
              p.mb-lg #{ cfg.command.description }

              if cfg.command.presets
                each preset, presetId in cfg.command.presets
                  div(class="preset " + preset.repos.join(' '))
                    h6.mb-md(id="link-"+presetId) #{commandStart} #{ commandName } #{presetId === 'default' ? '' : presetId}
                    p.mb-md.muted Works in these repos: [#{preset.repos.join(', ')}]
                    -let defaultArgs = []
                    if preset.args && Object.values(preset.args).length > 0
                      div.preset-args.mb-lg.ml-md
                        each arg, argKey in preset.args
                          div.row.mb-sm
                            // output only arrays with more than 1 element or regex (type_rule)
                            if arg.type_one_of && arg.type_one_of.length > 1
                              div.col-4.lowercase
                                | --#{arg.label}
                              div.col-8.lowercase
                                each one, i in arg.type_one_of
                                  span.mb-sm
                                    if i === 0
                                      | #{one} (default)&nbsp;
                                    else
                                      | | #{one}&nbsp;
                            else if arg.type_rule
                              div.col-4.lowercase
                                | --#{arg.label}
                                span(style="color: red;") &nbsp;*&nbsp;
                                | (required):
                              div.col-8.lowercase
                                | #{arg.type_rule}&nbsp;
                                if arg.example
                                  | (Example: "#{arg.example}")
                            else
                              -defaultArgs.push({[argKey]: arg})
                        if defaultArgs.length > 0
                          p.muted Default static args:
                          ul
                            each argObj in defaultArgs
                              each arg, argKey in argObj
                                if arg.type_one_of && arg.type_one_of.length === 1
                                  li.muted #{argKey}: #{arg.type_one_of[0]}
                                else if arg.type_string
                                  li.muted #{argKey}: #{arg.type_string}

                    p Example:&nbsp;
                      code
                        | #{commandStart} #{commandName} #{presetId === 'default' ? '' : presetId}
                        if preset.args
                          each arg, argKey in preset.args
                            if arg.type_rule
                              if arg.example
                                i &nbsp;--#{argKey}=#{arg.example}
                              else
                                i &nbsp;--#{argKey}=#{arg.type_rule}

              else
                p Example:&nbsp;
                  code
                    | #{commandStart} #{commandName}

          div(id="link-companion").command
            h5 Patch Companion

            p Syntax (after command name):
            p
              code -v PATCH_repo=pull_request_id

            p Examples:
            p
              code #{commandStart} bench -v PATCH_substrate=11341 polkadot-overhead --network=westend-dev
            p
              code #{commandStart} try-runtime -v PATCH_polkadot=3341 polkadot --network=westend

          div(id="link-new-command").command
            h5 Test new command.
            p When you create/modify a command in #{repoLink} repo, you can test it before merging to master

            p Syntax (after command name):
            p
              code -v PIPELINE_SCRIPTS_REF=your_branch

            p Examples:
            p
              code #{commandStart} new-command -v PIPELINE_SCRIPTS_REF=mak/new-command new-id --new-arg=value

          div(id="link-rust").command
            h5 Rust Log, etc
            p You can define custom env variables like for RUST env
            p Syntax (after command name):
            p
              code -v RUST_LOG=remote-ext=debug,runtime=trace

            p Examples:
            p
              code #{commandStart} try-runtime -v RUST_LOG=remote-ext=debug,runtime=trace polkadot --network=westend


    style.
      .command {
          margin-bottom: 100px;
      }

      .preset {
          margin-bottom: 80px;
          padding-left: 30px;
      }

      .preset-args {
          padding: 15px;
      }

      .preset h5 {
          margin-left: -30px;
      }

      .sticky-nav {
          position: -webkit-sticky; /* Safari */
          position: sticky;
          top: 10px;
          max-height: 100vh;
          max-height: 100 dvh; /* iOS dynamic viewport height */
          overflow-y: auto;
      }

      .mb-sm {
          margin-bottom: 5px;
      }

      .mb-md {
          margin-bottom: 15px;
      }

      .mt-sm {
          margin-top: 5px;
      }

      .ml-md {
          margin-top: 15px;
      }

      .mb-lg {
          margin-bottom: 30px;
      }

      .center {
          text-align: center;
      }

      .lowercase {
          text-transform: lowercase;
      }

      .muted {
          color: #6c757d;
      }

    script.
      document.getElementById('repos').addEventListener('change', function(e) {
        const selected = e.target.value;
        // update a query string
        const urlParams = new URLSearchParams(window.location.search);

        if (selected) {
            urlParams.set('repo', selected);
        } else {
            urlParams.delete('repo');
        }
        window.history.replaceState({}, '', `${location.pathname}${urlParams ? "?" + urlParams.toString() : ''}`);

        updatePresetLinks(selected);
      });

      const urlParams = new URLSearchParams(window.location.search);
      const repo = urlParams.get('repo');
      if (repo) {
        document.getElementById('repos').value = repo;
        updatePresetLinks(repo);
      }

      function updatePresetLinks(repo) {
        for (let preset of document.querySelectorAll('.preset, .preset-link')) {
          if (!repo || preset.classList.contains(repo)) {
            preset.style.display = 'block';
          } else {
            preset.style.display = 'none';
          }
        }

        // hide commands where all presets are hidden
        document.querySelectorAll('.command').forEach(function(command) {
          const presets = command.querySelectorAll('.preset');
          const visiblePresets = Array.from(presets).filter(function(preset) {
            return preset.style.display !== 'none';
          });
          if (visiblePresets.length === 0 && presets.length > 0) {
            command.style.display = 'none';
          } else {
            command.style.display = 'block';
          }
        });

        // hide nav where all presets are hidden
        document.querySelectorAll('.nav-command').forEach(function(command) {
          const presets = command.querySelectorAll('.nav-preset li');
          const visiblePresets = Array.from(presets).filter(function(preset) {
            return preset.style.display !== 'none';
          });
          if (visiblePresets.length === 0 && presets.length > 0) {
            command.style.display = 'none';
          } else {
            command.style.display = 'block';
          }
        });
      }
