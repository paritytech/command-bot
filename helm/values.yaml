# gcloud-sqlproxy:
#   serviceAccountName: "command-bot"
#   serviceAccount:
#     create: true
#     name: command-bot
#   networkPolicy:
#     enabled: false

common:
  fullnameOverride: "command-bot"
  extraLabels:
    team: "opstooling"
  serviceAccount:
    create: false
  image:
    repository: paritytech/command-bot
  envFrom:
    - secretRef:
        name: command-bot
  service:
    ports:
      - name: http
        protocol: TCP
        port: 80
        targetPort: 3000
  ingress:
    enabled: true
    annotations:
      cert-manager.io/cluster-issuer: letsencrypt-dns01
      kubernetes.io/ingress.class: traefik-external
      traefik.ingress.kubernetes.io/router.entrypoints: web,websecure
      traefik.ingress.kubernetes.io/router.tls: "true"
  persistence:
    enabled: true
    mountPath: ""
    subPath: ""
    annotations: {}
    storageClass: hdd-csi
    size: 100G
    accessModes:
      - ReadWriteOnce
  env:
    GITLAB_PUSH_NAMESPACE: parity/mirrors
    GITLAB_JOB_IMAGE: paritytech/ci-linux:production
    GITLAB_DOMAIN: gitlab.parity.io
    PIPELINE_SCRIPTS_REPOSITORY: https://github.com/paritytech/pipeline-scripts
  # We only want one instance at all times so that the execution queue can be
  # sanely tracked across multiple MRs.
  autoscaling:
    enabled: false
  # Enable after endpoint is created
  # livenessProbe:
  #   httpGet:
  #     path: /health
  #     port: 8000
  #     scheme: HTTP
  # readinessProbe:
  #   httpGet:
  #     path: /health
  #     port: 8000
  #     scheme: HTTP
